#import * from './helper.graphql'

#import Query from './query.graphql'

#import Mutation from './mutation.graphql'

type SystemInfo {
    title: String
    version: String
    uptime: String
    node_mem_usage: [String]
    platform: String
    os_type: String
    cpu_count: String
    os_total_mem: String
    os_free_mem: String
    user_count: String
    other_info: JSON
}

type UserAuthResponse {
    user: User
    token: String
    status: String
}

enum SignUpStep {
    GENERATE_ACTIVATION_CODE
    CHECK_ACTIVATION_CODE
}

######################################################################################

type ActivationCode {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    email: String!
    valid_until: DateTime!
    code: String!
}

type ActivationCodeConnection {
    pageInfo: PageInfo!
    edges: [ActivationCodeEdge]!
    aggregate: AggregateActivationCode!
}

input ActivationCodeCreateInput {
    email: String!
    valid_until: DateTime!
    code: String!
}

type ActivationCodeEdge {
    node: ActivationCode!
    cursor: String!
}

enum ActivationCodeOrderByInput {
    id_ASC
    id_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    email_ASC
    email_DESC
    valid_until_ASC
    valid_until_DESC
    code_ASC
    code_DESC
}

type ActivationCodePreviousValues {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    email: String!
    valid_until: DateTime!
    code: String!
}

type ActivationCodeSubscriptionPayload {
    mutation: MutationType!
    node: ActivationCode
    updatedFields: [String!]
    previousValues: ActivationCodePreviousValues
}

input ActivationCodeSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: ActivationCodeWhereInput
    AND: [ActivationCodeSubscriptionWhereInput!]
    OR: [ActivationCodeSubscriptionWhereInput!]
    NOT: [ActivationCodeSubscriptionWhereInput!]
}

input ActivationCodeUpdateInput {
    email: String
    valid_until: DateTime
    code: String
}

input ActivationCodeUpdateManyMutationInput {
    email: String
    valid_until: DateTime
    code: String
}

input ActivationCodeWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    email: String
    email_not: String
    email_in: [String!]
    email_not_in: [String!]
    email_lt: String
    email_lte: String
    email_gt: String
    email_gte: String
    email_contains: String
    email_not_contains: String
    email_starts_with: String
    email_not_starts_with: String
    email_ends_with: String
    email_not_ends_with: String
    valid_until: DateTime
    valid_until_not: DateTime
    valid_until_in: [DateTime!]
    valid_until_not_in: [DateTime!]
    valid_until_lt: DateTime
    valid_until_lte: DateTime
    valid_until_gt: DateTime
    valid_until_gte: DateTime
    code: String
    code_not: String
    code_in: [String!]
    code_not_in: [String!]
    code_lt: String
    code_lte: String
    code_gt: String
    code_gte: String
    code_contains: String
    code_not_contains: String
    code_starts_with: String
    code_not_starts_with: String
    code_ends_with: String
    code_not_ends_with: String
    AND: [ActivationCodeWhereInput!]
    OR: [ActivationCodeWhereInput!]
    NOT: [ActivationCodeWhereInput!]
}

input ActivationCodeWhereUniqueInput {
    id: ID
    email: String
}

type AggregateActivationCode {
    count: Int!
}

type AggregateCategory {
    count: Int!
}

type AggregateProduct {
    count: Int!
}

type AggregateUser {
    count: Int!
}

type BatchPayload {
    count: Long!
}

type Category {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    title: String!
    description: String
    subcategories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category!]
    products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type CategoryConnection {
    pageInfo: PageInfo!
    edges: [CategoryEdge]!
    aggregate: AggregateCategory!
}

input CategoryCreateInput {
    title: String!
    description: String
    subcategories: CategoryCreateManyInput
    products: ProductCreateManyWithoutCategoriesInput
}

input CategoryCreateManyInput {
    create: [CategoryCreateInput!]
    connect: [CategoryWhereUniqueInput!]
}

input CategoryCreateManyWithoutProductsInput {
    create: [CategoryCreateWithoutProductsInput!]
    connect: [CategoryWhereUniqueInput!]
}

input CategoryCreateWithoutProductsInput {
    title: String!
    description: String
    subcategories: CategoryCreateManyInput
}

type CategoryEdge {
    node: Category!
    cursor: String!
}

enum CategoryOrderByInput {
    id_ASC
    id_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    title_ASC
    title_DESC
    description_ASC
    description_DESC
}

type CategoryPreviousValues {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    title: String!
    description: String
}

input CategoryScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    title: String
    title_not: String
    title_in: [String!]
    title_not_in: [String!]
    title_lt: String
    title_lte: String
    title_gt: String
    title_gte: String
    title_contains: String
    title_not_contains: String
    title_starts_with: String
    title_not_starts_with: String
    title_ends_with: String
    title_not_ends_with: String
    description: String
    description_not: String
    description_in: [String!]
    description_not_in: [String!]
    description_lt: String
    description_lte: String
    description_gt: String
    description_gte: String
    description_contains: String
    description_not_contains: String
    description_starts_with: String
    description_not_starts_with: String
    description_ends_with: String
    description_not_ends_with: String
    AND: [CategoryScalarWhereInput!]
    OR: [CategoryScalarWhereInput!]
    NOT: [CategoryScalarWhereInput!]
}

type CategorySubscriptionPayload {
    mutation: MutationType!
    node: Category
    updatedFields: [String!]
    previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: CategoryWhereInput
    AND: [CategorySubscriptionWhereInput!]
    OR: [CategorySubscriptionWhereInput!]
    NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateDataInput {
    title: String
    description: String
    subcategories: CategoryUpdateManyInput
    products: ProductUpdateManyWithoutCategoriesInput
}

input CategoryUpdateInput {
    title: String
    description: String
    subcategories: CategoryUpdateManyInput
    products: ProductUpdateManyWithoutCategoriesInput
}

input CategoryUpdateManyDataInput {
    title: String
    description: String
}

input CategoryUpdateManyInput {
    create: [CategoryCreateInput!]
    update: [CategoryUpdateWithWhereUniqueNestedInput!]
    upsert: [CategoryUpsertWithWhereUniqueNestedInput!]
    delete: [CategoryWhereUniqueInput!]
    connect: [CategoryWhereUniqueInput!]
    set: [CategoryWhereUniqueInput!]
    disconnect: [CategoryWhereUniqueInput!]
    deleteMany: [CategoryScalarWhereInput!]
    updateMany: [CategoryUpdateManyWithWhereNestedInput!]
}

input CategoryUpdateManyMutationInput {
    title: String
    description: String
}

input CategoryUpdateManyWithoutProductsInput {
    create: [CategoryCreateWithoutProductsInput!]
    delete: [CategoryWhereUniqueInput!]
    connect: [CategoryWhereUniqueInput!]
    set: [CategoryWhereUniqueInput!]
    disconnect: [CategoryWhereUniqueInput!]
    update: [CategoryUpdateWithWhereUniqueWithoutProductsInput!]
    upsert: [CategoryUpsertWithWhereUniqueWithoutProductsInput!]
    deleteMany: [CategoryScalarWhereInput!]
    updateMany: [CategoryUpdateManyWithWhereNestedInput!]
}

input CategoryUpdateManyWithWhereNestedInput {
    where: CategoryScalarWhereInput!
    data: CategoryUpdateManyDataInput!
}

input CategoryUpdateWithoutProductsDataInput {
    title: String
    description: String
    subcategories: CategoryUpdateManyInput
}

input CategoryUpdateWithWhereUniqueNestedInput {
    where: CategoryWhereUniqueInput!
    data: CategoryUpdateDataInput!
}

input CategoryUpdateWithWhereUniqueWithoutProductsInput {
    where: CategoryWhereUniqueInput!
    data: CategoryUpdateWithoutProductsDataInput!
}

input CategoryUpsertWithWhereUniqueNestedInput {
    where: CategoryWhereUniqueInput!
    update: CategoryUpdateDataInput!
    create: CategoryCreateInput!
}

input CategoryUpsertWithWhereUniqueWithoutProductsInput {
    where: CategoryWhereUniqueInput!
    update: CategoryUpdateWithoutProductsDataInput!
    create: CategoryCreateWithoutProductsInput!
}

input CategoryWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    title: String
    title_not: String
    title_in: [String!]
    title_not_in: [String!]
    title_lt: String
    title_lte: String
    title_gt: String
    title_gte: String
    title_contains: String
    title_not_contains: String
    title_starts_with: String
    title_not_starts_with: String
    title_ends_with: String
    title_not_ends_with: String
    description: String
    description_not: String
    description_in: [String!]
    description_not_in: [String!]
    description_lt: String
    description_lte: String
    description_gt: String
    description_gte: String
    description_contains: String
    description_not_contains: String
    description_starts_with: String
    description_not_starts_with: String
    description_ends_with: String
    description_not_ends_with: String
    subcategories_every: CategoryWhereInput
    subcategories_some: CategoryWhereInput
    subcategories_none: CategoryWhereInput
    products_every: ProductWhereInput
    products_some: ProductWhereInput
    products_none: ProductWhereInput
    AND: [CategoryWhereInput!]
    OR: [CategoryWhereInput!]
    NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
    id: ID
}

enum MutationType {
    CREATED
    UPDATED
    DELETED
}

interface Node {
    id: ID!
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
}

type Product {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    title: String!
    description: String
    categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category!]
}

type ProductConnection {
    pageInfo: PageInfo!
    edges: [ProductEdge]!
    aggregate: AggregateProduct!
}

input ProductCreateInput {
    title: String!
    description: String
    categories: CategoryCreateManyWithoutProductsInput
}

input ProductCreateManyWithoutCategoriesInput {
    create: [ProductCreateWithoutCategoriesInput!]
    connect: [ProductWhereUniqueInput!]
}

input ProductCreateWithoutCategoriesInput {
    title: String!
    description: String
}

type ProductEdge {
    node: Product!
    cursor: String!
}

enum ProductOrderByInput {
    id_ASC
    id_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    title_ASC
    title_DESC
    description_ASC
    description_DESC
}

type ProductPreviousValues {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    title: String!
    description: String
}

input ProductScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    title: String
    title_not: String
    title_in: [String!]
    title_not_in: [String!]
    title_lt: String
    title_lte: String
    title_gt: String
    title_gte: String
    title_contains: String
    title_not_contains: String
    title_starts_with: String
    title_not_starts_with: String
    title_ends_with: String
    title_not_ends_with: String
    description: String
    description_not: String
    description_in: [String!]
    description_not_in: [String!]
    description_lt: String
    description_lte: String
    description_gt: String
    description_gte: String
    description_contains: String
    description_not_contains: String
    description_starts_with: String
    description_not_starts_with: String
    description_ends_with: String
    description_not_ends_with: String
    AND: [ProductScalarWhereInput!]
    OR: [ProductScalarWhereInput!]
    NOT: [ProductScalarWhereInput!]
}

type ProductSubscriptionPayload {
    mutation: MutationType!
    node: Product
    updatedFields: [String!]
    previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: ProductWhereInput
    AND: [ProductSubscriptionWhereInput!]
    OR: [ProductSubscriptionWhereInput!]
    NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateInput {
    title: String
    description: String
    categories: CategoryUpdateManyWithoutProductsInput
}

input ProductUpdateManyDataInput {
    title: String
    description: String
}

input ProductUpdateManyMutationInput {
    title: String
    description: String
}

input ProductUpdateManyWithoutCategoriesInput {
    create: [ProductCreateWithoutCategoriesInput!]
    delete: [ProductWhereUniqueInput!]
    connect: [ProductWhereUniqueInput!]
    set: [ProductWhereUniqueInput!]
    disconnect: [ProductWhereUniqueInput!]
    update: [ProductUpdateWithWhereUniqueWithoutCategoriesInput!]
    upsert: [ProductUpsertWithWhereUniqueWithoutCategoriesInput!]
    deleteMany: [ProductScalarWhereInput!]
    updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithWhereNestedInput {
    where: ProductScalarWhereInput!
    data: ProductUpdateManyDataInput!
}

input ProductUpdateWithoutCategoriesDataInput {
    title: String
    description: String
}

input ProductUpdateWithWhereUniqueWithoutCategoriesInput {
    where: ProductWhereUniqueInput!
    data: ProductUpdateWithoutCategoriesDataInput!
}

input ProductUpsertWithWhereUniqueWithoutCategoriesInput {
    where: ProductWhereUniqueInput!
    update: ProductUpdateWithoutCategoriesDataInput!
    create: ProductCreateWithoutCategoriesInput!
}

input ProductWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    title: String
    title_not: String
    title_in: [String!]
    title_not_in: [String!]
    title_lt: String
    title_lte: String
    title_gt: String
    title_gte: String
    title_contains: String
    title_not_contains: String
    title_starts_with: String
    title_not_starts_with: String
    title_ends_with: String
    title_not_ends_with: String
    description: String
    description_not: String
    description_in: [String!]
    description_not_in: [String!]
    description_lt: String
    description_lte: String
    description_gt: String
    description_gte: String
    description_contains: String
    description_not_contains: String
    description_starts_with: String
    description_not_starts_with: String
    description_ends_with: String
    description_not_ends_with: String
    categories_every: CategoryWhereInput
    categories_some: CategoryWhereInput
    categories_none: CategoryWhereInput
    AND: [ProductWhereInput!]
    OR: [ProductWhereInput!]
    NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
    id: ID
}

type User {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    email: String!
    roles: [UserRole!]!
    avatar: String
    last_login_date: DateTime
}

type UserConnection {
    pageInfo: PageInfo!
    edges: [UserEdge]!
    aggregate: AggregateUser!
}

input UserCreateInput {
    email: String!
    roles: UserCreaterolesInput
    avatar: String
    last_login_date: DateTime
}

input UserCreaterolesInput {
    set: [UserRole!]
}

type UserEdge {
    node: User!
    cursor: String!
}

enum UserOrderByInput {
    id_ASC
    id_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    email_ASC
    email_DESC
    avatar_ASC
    avatar_DESC
    last_login_date_ASC
    last_login_date_DESC
}

type UserPreviousValues {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    email: String!
    roles: [UserRole!]!
    avatar: String
    last_login_date: DateTime
}

enum UserRole {
    USER
    MODERATOR
    ADMIN
}

type UserSubscriptionPayload {
    mutation: MutationType!
    node: User
    updatedFields: [String!]
    previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: UserWhereInput
    AND: [UserSubscriptionWhereInput!]
    OR: [UserSubscriptionWhereInput!]
    NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
    email: String
    roles: UserUpdaterolesInput
    avatar: String
    last_login_date: DateTime
}

input UserUpdateManyMutationInput {
    email: String
    roles: UserUpdaterolesInput
    avatar: String
    last_login_date: DateTime
}

input UserUpdaterolesInput {
    set: [UserRole!]
}

input UserWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    email: String
    email_not: String
    email_in: [String!]
    email_not_in: [String!]
    email_lt: String
    email_lte: String
    email_gt: String
    email_gte: String
    email_contains: String
    email_not_contains: String
    email_starts_with: String
    email_not_starts_with: String
    email_ends_with: String
    email_not_ends_with: String
    avatar: String
    avatar_not: String
    avatar_in: [String!]
    avatar_not_in: [String!]
    avatar_lt: String
    avatar_lte: String
    avatar_gt: String
    avatar_gte: String
    avatar_contains: String
    avatar_not_contains: String
    avatar_starts_with: String
    avatar_not_starts_with: String
    avatar_ends_with: String
    avatar_not_ends_with: String
    last_login_date: DateTime
    last_login_date_not: DateTime
    last_login_date_in: [DateTime!]
    last_login_date_not_in: [DateTime!]
    last_login_date_lt: DateTime
    last_login_date_lte: DateTime
    last_login_date_gt: DateTime
    last_login_date_gte: DateTime
    AND: [UserWhereInput!]
    OR: [UserWhereInput!]
    NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
    id: ID
    email: String
}
